name: Build and publish SSAS

on:
  workflow_call:
    inputs:
      revision:
        description: 'Revision to release (tag or branch name)'
        required: true
        type: string
      env:
        description: 'Environment you want to deploy to (dev, test, sandbox, prod)'
        required: true
        type: string
        default: dev
      confirm_env:
        description: 'Confirm the environment you want to deploy to'
        required: true
        type: string
        default: dev
  workflow_dispatch:
    inputs:
      revision:
        description: 'Revision to release for SSAS (tag or branch name)'
        required: true
        type: string
      env:
        description: 'Environment you want to deploy to (dev, test, sandbox, prod)'
        required: true
        default: dev
        type: choice
        options:
          - dev
          - test
          - sandbox
          - prod
      confirm_env:
        description: 'Confirm the environment you want to deploy to'
        required: true
        default: dev
        type: choice
        options:
          - dev
          - test
          - sandbox
          - prod

permissions:
  id-token: write
  contents: read

env:
  RELEASE_ENV: ${{ inputs.env || 'dev' }}
  CONFIRM_RELEASE_ENV: ${{ inputs.confirm_env || 'dev' }}
  VERSION: ${{ inputs.revision }} # version to be released; starts with 'r' for tags and 'f' for everything else


jobs:
  # FARGATE FIXME: unnecessary and causes errors when running ci_checks more than once for a single build
  # This should be commented back in when build-and-package is no longer around.
  # ci_checks:
  #   uses: ./.github/workflows/ci-checks.yml
  #   with:
  #     ssas_release_version: ${{ inputs.revision || 'main' }}
  #   secrets: inherit

  build_and_publish:
    # needs: [ci_checks]
    environment: ${{ inputs.env || 'dev' }}
    runs-on: codebuild-bcda-app-${{github.run_id}}-${{github.run_attempt}}

    steps:
      - name: Get Workflow Inputs
        run: echo "${{ toJSON(inputs) }}"
      - name: Confirm Env
        if: ${{ env.RELEASE_ENV != env.CONFIRM_RELEASE_ENV }}
        run: |
          echo "Target deployment env ${{ env.RELEASE_ENV }} must match confirmed deployment env ${{ env.CONFIRM_RELEASE_ENV }}."
          exit 1
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/delegatedadmin/developer/${{ vars.AWS_ROLE_TO_ASSUME }}
      - name: Checkout SSAS
        uses: actions/checkout@v4
        with:
          repository: CMSgov/bcda-ssas-app
          ref: ${{ inputs.revision }}
      - name: Set Version
        run: |
          RV="${{ inputs.revision }}"
          LENGTH=${#RV}
          if [[ $rv == r* && $LENGTH -lt 6 ]]; then
            echo "Revision is a tag; setting version to tag name"
            echo "VERSION=${{ inputs.revision }}" >> $GITHUB_ENV
          else
            echo "Revision is not a tag; setting version to revision shorthand"
            rev=$(git rev-parse --short HEAD)
            echo "VERSION=f$rev" >> $GITHUB_ENV
          fi
      - name: Set ECR_URL
        run: echo "ECR_URL=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com/bcda-${{ env.RELEASE_ENV }}-ssas" >> $GITHUB_ENV
      - name: Build SSAS
        # Dont release main to prod, also makes sure 'latest' in prod aligns with the latest release tag
        # if: ${{ env.RELEASE_ENV == 'dev' || env.RELEASE_ENV == 'test' || startsWith(env.VERSION, 'r') }} TODO: restore when ECR exists in prod
        if: ${{ env.RELEASE_ENV == 'dev' || env.RELEASE_ENV == 'test' || env.RELEASE_ENV == 'sandbox' }}
        run: |
          docker build \
            --build-arg RELEASE_VERSION=${{ env.VERSION }} \
            -t ${{ env.ECR_URL }}:latest \
            -t ${{ env.ECR_URL }}:${{ env.VERSION }} \
            -f Dockerfiles/Dockerfile.ssas .
      - name: Push to ECR
        # if: ${{ env.RELEASE_ENV == 'dev' || env.RELEASE_ENV == 'test' || startsWith(env.VERSION, 'r') }} TODO: restore when ECR exists in prod
        if: ${{ env.RELEASE_ENV == 'dev' || env.RELEASE_ENV == 'test' || env.RELEASE_ENV == 'sandbox' }}
        run: |
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin '${{ env.ECR_URL }}'
          docker image push '${{ env.ECR_URL }}' -a
